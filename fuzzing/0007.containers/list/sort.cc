#include <fast_io.h>
#include <fast_io_dsal/list.h>
#include <fast_io_dsal/span.h>
#include <algorithm>
#include <limits>

// This code is generated by DeepSeek, an AI assistant, and enhanced by Copilot.
// For more information, visit https://www.deepseek.com and https://copilot.microsoft.com.

extern "C" int LLVMFuzzerTestOneInput(::std::uint8_t *data, ::std::size_t size)
{
	auto first{reinterpret_cast<::std::size_t *>(data)};
	auto last{first + size / sizeof(::std::size_t)};
	::fast_io::span<::std::size_t> sp(first, last);

	// Test empty list
	if (sp.empty())
	{
		::fast_io::list<::std::size_t> list;
		list.sort();
		if (list.begin() != list.end()) [[unlikely]]
		{
			::fast_io::panic("Empty list should remain empty after sort");
		}
		return 0;
	}

	// Test single-element list
	if (sp.size() == 1)
	{
		::fast_io::list<::std::size_t> list(::std::from_range, sp);
		list.sort();
		if (list.front() != sp.front()) [[unlikely]]
		{
			::fast_io::panic("Single element list should remain unchanged after sort");
		}
		return 0;
	}

	// Test normal list
	::fast_io::list<::std::size_t> list(::std::from_range, sp);
	list.sort();
	if (static_cast<::std::size_t>(std::ranges::distance(list)) != sp.size() ||
		!::std::ranges::is_sorted(list)) [[unlikely]]
	{
		::fast_io::panic("List not sorted:\n", ::fast_io::mnp::rgvw(list, "\n"));
	}

	// Test list with duplicate elements
	::fast_io::list<::std::size_t> list_with_duplicates(::std::from_range, sp);
	list_with_duplicates.push_back(sp.front());
	list_with_duplicates.sort();
	if (!::std::ranges::is_sorted(list_with_duplicates)) [[unlikely]]
	{
		::fast_io::panic("List with duplicates not sorted:\n", ::fast_io::mnp::rgvw(list_with_duplicates, "\n"));
	}

	// Test large list
	if (sp.size() > 1000)
	{
		::fast_io::list<::std::size_t> large_list(::std::from_range, sp);
		large_list.sort();
		if (!::std::ranges::is_sorted(large_list)) [[unlikely]]
		{
			::fast_io::panic("Large list not sorted:\n", ::fast_io::mnp::rgvw(large_list, "\n"));
		}
	}

	// Test already sorted list
	if (::std::ranges::is_sorted(sp))
	{
		::fast_io::list<::std::size_t> sorted_list(::std::from_range, sp);
		sorted_list.sort();
		if (!::std::ranges::is_sorted(sorted_list)) [[unlikely]]
		{
			::fast_io::panic("Already sorted list should remain sorted:\n", ::fast_io::mnp::rgvw(sorted_list, "\n"));
		}
		return 0;
	}

	// Test descending order list
	if (::std::ranges::is_sorted(sp, ::std::ranges::greater{}))
	{
		::fast_io::list<::std::size_t> desc_list(::std::from_range, sp);
		desc_list.sort();
		if (!::std::ranges::is_sorted(desc_list)) [[unlikely]]
		{
			::fast_io::panic("Descending order list should be sorted:\n", ::fast_io::mnp::rgvw(desc_list, "\n"));
		}
		return 0;
	}

	// Test list with maximum and minimum size_t values
	if (::std::ranges::any_of(sp, [](auto val) { return val == std::numeric_limits<::std::size_t>::max(); }) &&
		::std::ranges::any_of(sp, [](auto val) { return val == std::numeric_limits<::std::size_t>::min(); }))
	{
		::fast_io::list<::std::size_t> min_max_list(::std::from_range, sp);
		min_max_list.sort();
		if (!::std::ranges::is_sorted(min_max_list)) [[unlikely]]
		{
			::fast_io::panic("List with max and min size_t values not sorted:\n", ::fast_io::mnp::rgvw(min_max_list, "\n"));
		}
		return 0;
	}

	// Test push_front, push_back, pop_front, and pop_back on the same list
	::fast_io::list<::std::size_t> all_ops_list(::std::from_range, sp);
	all_ops_list.push_front(0);
	all_ops_list.push_back(0);
	all_ops_list.pop_front();
	all_ops_list.pop_back();
	all_ops_list.sort();
	if (!::std::ranges::is_sorted(all_ops_list)) [[unlikely]]
	{
		::fast_io::panic("List after push_front, push_back, pop_front, and pop_back not sorted:\n", ::fast_io::mnp::rgvw(all_ops_list, "\n"));
	}

	// Test merge with another sorted list
	::fast_io::list<::std::size_t> merge_list(::std::from_range, sp);
	merge_list.sort();
	::fast_io::list<::std::size_t> another_list{1, 2, 3};
	another_list.sort();
	merge_list.merge(std::move(another_list));
	if (!::std::ranges::is_sorted(merge_list)) [[unlikely]]
	{
		::fast_io::panic("Merged list not sorted:\n", ::fast_io::mnp::rgvw(merge_list, "\n"));
	}

	return 0;
}
