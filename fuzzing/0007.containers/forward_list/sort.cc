#include <fast_io.h>
#include <fast_io_dsal/forward_list.h>
#include <fast_io_dsal/span.h>
#include <algorithm>
#include <limits>

// This code is generated by DeepSeek, an AI assistant, and enhanced by Copilot.
// For more information, visit https://www.deepseek.com and https://copilot.microsoft.com.

extern "C" int LLVMFuzzerTestOneInput(::std::uint8_t *data, ::std::size_t size)
{
	auto first{reinterpret_cast<::std::size_t *>(data)};
	auto last{first + size / sizeof(::std::size_t)};
	::fast_io::span<::std::size_t> sp(first, last);

	// Test empty list
	if (sp.empty())
	{
		::fast_io::forward_list<::std::size_t> flist;
		flist.sort();
		if (!flist.empty()) [[unlikely]]
		{
			::fast_io::panic("Empty list should remain empty after sort");
		}
		return 0;
	}

	// Test single-element list
	if (sp.size() == 1)
	{
		::fast_io::forward_list<::std::size_t> flist(::std::from_range, sp);
		flist.sort();
		if (flist.front() != sp.front()) [[unlikely]]
		{
			::fast_io::panic("Single element list should remain unchanged after sort");
		}
		return 0;
	}

	// Test normal list
	::fast_io::forward_list<::std::size_t> flist(::std::from_range, sp);
	flist.sort();
	if (sp.size() != static_cast<::std::size_t>(::std::ranges::distance(flist)) ||
		!::std::ranges::is_sorted(flist)) [[unlikely]]
	{
		::fast_io::panic("flist not sorted:\n", ::fast_io::mnp::rgvw(flist, "\n"));
	}

	// Test list with duplicate elements
	::fast_io::forward_list<::std::size_t> flist_with_duplicates(::std::from_range, sp);
	flist_with_duplicates.insert_after(flist_with_duplicates.before_begin(), sp.front());
	flist_with_duplicates.sort();
	if (!::std::ranges::is_sorted(flist_with_duplicates)) [[unlikely]]
	{
		::fast_io::panic("flist with duplicates not sorted:\n", ::fast_io::mnp::rgvw(flist_with_duplicates, "\n"));
	}

	// Test large list
	if (sp.size() > 1000)
	{
		::fast_io::forward_list<::std::size_t> large_flist(::std::from_range, sp);
		large_flist.sort();
		if (!::std::ranges::is_sorted(large_flist)) [[unlikely]]
		{
			::fast_io::panic("Large flist not sorted:\n", ::fast_io::mnp::rgvw(large_flist, "\n"));
		}
	}

	// Test already sorted list
	if (::std::ranges::is_sorted(sp))
	{
		::fast_io::forward_list<::std::size_t> sorted_flist(::std::from_range, sp);
		sorted_flist.sort();
		if (!::std::ranges::is_sorted(sorted_flist)) [[unlikely]]
		{
			::fast_io::panic("Already sorted list should remain sorted:\n", ::fast_io::mnp::rgvw(sorted_flist, "\n"));
		}
		return 0;
	}

	// Test descending order list
	if (::std::ranges::is_sorted(sp, ::std::ranges::greater{}))
	{
		::fast_io::forward_list<::std::size_t> desc_flist(::std::from_range, sp);
		desc_flist.sort();
		if (!::std::ranges::is_sorted(desc_flist)) [[unlikely]]
		{
			::fast_io::panic("Descending order list should be sorted:\n", ::fast_io::mnp::rgvw(desc_flist, "\n"));
		}
		return 0;
	}

	// Test list with maximum and minimum size_t values
	if (::std::ranges::any_of(sp, [](auto val) { return val == std::numeric_limits<::std::size_t>::max(); }) &&
		::std::ranges::any_of(sp, [](auto val) { return val == std::numeric_limits<::std::size_t>::min(); }))
	{
		::fast_io::forward_list<::std::size_t> min_max_flist(::std::from_range, sp);
		min_max_flist.sort();
		if (!::std::ranges::is_sorted(min_max_flist)) [[unlikely]]
		{
			::fast_io::panic("List with max and min size_t values not sorted:\n", ::fast_io::mnp::rgvw(min_max_flist, "\n"));
		}
		return 0;
	}

	// Test push_front and pop_front
	::fast_io::forward_list<::std::size_t> push_pop_flist(::std::from_range, sp);
	push_pop_flist.push_front(0);
	push_pop_flist.pop_front();
	push_pop_flist.sort();
	if (!::std::ranges::is_sorted(push_pop_flist)) [[unlikely]]
	{
		::fast_io::panic("List after push_front and pop_front not sorted:\n", ::fast_io::mnp::rgvw(push_pop_flist, "\n"));
	}

	// Test merge with another sorted list
	::fast_io::forward_list<::std::size_t> merge_flist(::std::from_range, sp);
	merge_flist.sort();
	::fast_io::forward_list<::std::size_t> another_list{1, 2, 3};
	another_list.sort();
	merge_flist.merge(std::move(another_list));
	if (!::std::ranges::is_sorted(merge_flist)) [[unlikely]]
	{
		::fast_io::panic("Merged list not sorted:\n", ::fast_io::mnp::rgvw(merge_flist, "\n"));
	}

	return 0;
}
